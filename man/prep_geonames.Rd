% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prep_geonames.R
\name{prep_geonames}
\alias{prep_geonames}
\title{Interactive Admin Name Cleaning and Matching}
\usage{
prep_geonames(
  target_df,
  lookup_df = NULL,
  level0 = NULL,
  level1 = NULL,
  level2 = NULL,
  level3 = NULL,
  level4 = NULL,
  cache_path = NULL,
  unmatched_export_path = NULL,
  method = "jw",
  interactive = TRUE,
  max_options = 200,
  preserve_case = FALSE,
  column_width = 60
)
}
\arguments{
\item{target_df}{Data frame containing the admin names to clean.}

\item{lookup_df}{Lookup data frame for verifying admin names. If this is not
provided, an internal version of WHO geoname data
attached to sntutils is used.}

\item{level0}{level0 col name (country) in both 'data' and 'lookup_data'.}

\item{level1}{level1 col name (province) in both 'data' and 'lookup_data'.}

\item{level2}{level2 col name (district) in both 'data' and 'lookup_data'.}

\item{level3}{level3 col name (subdistrict) in both 'data' and 'lookup_data'.}

\item{level4}{level4 col name (settlement) in both 'data' and 'lookup_data'.}

\item{cache_path}{Optional; the path where the cache data frame is
saved after user modifications. Supports all file formats supported
by sntutils read() and write() functions including .rds, .csv, .xlsx,
.dta, .tsv, and more. This path is also used to match and integrate
previously established corrections into the current session. If NULL
or the file does not exist at the provided path, users will be
prompted to specify a new path or create a new cache data frame.}

\item{unmatched_export_path}{Optional; path to save unmatched data after
processing. The file will include complete rows with full hierarchical
context, showing which column needs matching (typically the most
granular level like health facilities) along with all administrative
levels and metadata (timestamp, username, data sources). Supports all
file formats supported by sntutils write() function based on the file
extension.}

\item{method}{The string distance calculation method(s) to be used. Users
can specify one or more algorithms from the
\code{\link[stringdist]{stringdist}} package to compute
string distances between admin names. The function by
default uses \code{"jw"} (Jaro-Winkler). Other options include:
\code{"lv"} (Levenshtein), \code{"dl"}
(Damerau-Levenshtein), \code{"lcs"} (Longest Common Subsequence),
\code{"qgram"} (Q-Gram), \code{"jw"} (Jaro-Winkler), and
\code{"soundex"}.}

\item{interactive}{Logical; if TRUE, prompts the user for interactive
matching decisions. Defaults to FALSE.}

\item{max_options}{Maximum number of options to output for string distance
matching. Default is 200.}

\item{preserve_case}{Logical; if TRUE, preserves the original case of admin
names from the lookup data when returning matched values. If FALSE
(default), returns all admin names in uppercase as before.}

\item{column_width}{Numeric; the maximum width (in characters) for each
column in the interactive menu. Controls how much text is displayed
before truncation. Default is 60 characters. Note that the actual
text display width is approximately 8 characters less to accommodate
number labels and truncation markers ("...").}
}
\value{
A data frame with cleaned administrative names and saved data frame
of user decisions.
}
\description{
This function streamlines the admin name cleaning process, leveraging both
algorithmic approaches and interactive user decisions. It combines string
distance algorithms for initial matching and offers user interactivity for
final decision-making, which are then saved for future reference and sharing.
Although the function does not require limiting name matching exclusively to
upper-level admins, optimal performance is achieved by confining to stricter
within-admin stratifications,
ensuring more accurate results. The function can also work with site names
or even any string matching that has lookup data.
}
\details{
The function performs the following steps:
\enumerate{
\item Prepares the data by ensuring administrative names are in uppercase for
consistent matching.
\item Attempts to load a previously saved cache file if available, or
initializes the cleaning process.
\item Matches administrative names between \code{target_df} and \code{lookup_df} using
string distance algorithms, running in parallel. Results are ranked
by closeness.
\item Engages the user through an interactive CLI menu to make decisions on
ambiguous matches.
\item Saves the user's decisions in a cache data frame, either to a specified
path or by prompting the user for a location.
\item Returns a cleaned data frame with updated administrative names based on
user choices and algorithmic matching.
}
}
\examples{
\donttest{
# Dummy target data
target_df <- data.frame(
  country = c("ANGOLA", "UGA", "ZAMBIA"),
  province = c("CABONDA", "TESO", "LUSAKA"),
  district = c("BALIZE", "BOKEDEA", "RAFUNSA"),
  subdistrict = c("AREA1", "AREA2", "AREA3")
)

# Dummy lookup data with correct spellings
lookup_df <- data.frame(
  country = c("ANGOLA", "ANGOLA", "UGANDA", "UGANDA", "ZAMBIA", "ZAMBIA"),
  province = c("CABINDA", "CABINDA", "TESO", "TESO", "LUSAKA", "LUSAKA"),
  district = c("BELIZE", "BUCO-ZAU", "BUKEDEA", "KUMI", "KAFUE", "LUSAKA"),
  stringsAsFactors = FALSE
)

# Interactively clean geonames
prep_geonames(
  target_df,
  lookup_df = lookup_df,
  level0 = "country", level1 = "province",
  level2 = "district",
  interactive = FALSE # replace with TRUE for interactivity
)
}

}
