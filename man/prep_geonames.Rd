% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prep_geonames.R
\name{prep_geonames}
\alias{prep_geonames}
\title{Interactive Admin Name Cleaning and Matching}
\usage{
prep_geonames(
  target_df,
  lookup_df = NULL,
  level0 = NULL,
  level1 = NULL,
  level2 = NULL,
  level3 = NULL,
  level4 = NULL,
  cache_path = NULL,
  unmatched_export_path = NULL,
  method = "jw",
  interactive = TRUE,
  max_options = 200,
  preserve_case = FALSE
)
}
\arguments{
\item{target_df}{Data frame containing the admin names to clean.}

\item{lookup_df}{Lookup data frame for verifying admin names.}

\item{level0}{level0 col name (country) in both 'data' and 'lookup_data'.}

\item{level1}{level1 col name (province) in both 'data' and 'lookup_data'.}

\item{level2}{level2 col name (district) in both 'data' and 'lookup_data'.}

\item{level3}{level3 col name (subdistrict) in both 'data' and 'lookup_data'.}

\item{level4}{level4 col name (settlement) in both 'data' and 'lookup_data'.}

\item{cache_path}{Optional; the path where the cache data frame is
saved after user modifications. This path is also used to match and
integrate previously established corrections into the current
session. If NULL or the file does not exist at the provided path,
users will be prompted to specify a new path or create a new cache
data frame.}

\item{unmatched_export_path}{Optional; path to save unmatched data after
processing. The file will include complete rows with full hierarchical
context, showing which column needs matching (typically the most
granular level like health facilities) along with all administrative
levels and metadata (timestamp, username, data sources). Supports .csv
and .rds file formats based on the file extension.}

\item{method}{The string distance calculation method(s) to be used. Users
can specify one or more algorithms from the
\code{\link[stringdist]{stringdist}} package to compute
string distances between admin names. The function by
default uses \code{"jw"} (Jaro-Winkler). Other options include:
\code{"lv"} (Levenshtein), \code{"dl"}
(Damerau-Levenshtein), \code{"lcs"} (Longest Common Subsequence),
\code{"qgram"} (Q-Gram), \code{"jw"} (Jaro-Winkler), and
\code{"soundex"}.}

\item{interactive}{Logical; if TRUE, prompts the user for interactive
matching decisions. Defaults to FALSE.}

\item{max_options}{Maximum number of options to output for string distance
matching. Default is 200.}

\item{preserve_case}{Logical; if TRUE, preserves the original case of admin
names from the lookup data when returning matched values. If FALSE
(default), returns all admin names in uppercase as before.}
}
\value{
A data frame with cleaned administrative names and saved data frame
of user decisions.
}
\description{
This function streamlines the admin name cleaning process, leveraging both
algorithmic approaches and interactive user decisions. It combines string
distance algorithms for initial matching and offers user interactivity for
final decision-making, which are then saved for future reference and sharing.
Although the function does not require limiting name matching exclusively to
upper-level admins, optimal performance is achieved by confining to stricter
within-admin stratifications,
ensuring more accurate results. The function can also work with site names
or even any string matching that has lookup data.
}
\details{
The function performs the following steps:
\enumerate{
\item Prepares the data by ensuring administrative names are in uppercase for
consistent matching.
\item Attempts to load a previously saved cache file if available, or
initializes the cleaning process.
\item Matches administrative names between \code{target_df} and \code{lookup_df} using
string distance algorithms, running in parallel. Results are ranked
by closeness.
\item Engages the user through an interactive CLI menu to make decisions on
ambiguous matches.
\item Saves the user's decisions in a cache data frame, either to a specified
path or by prompting the user for a location.
\item Returns a cleaned data frame with updated administrative names based on
user choices and algorithmic matching.
}
}
\examples{
\donttest{
# Dummy target data
target_df <- data.frame(
  country = c("ANGOLA", "UGA", "ZAMBIA"),
  province = c("CABONDA", "TESO", "LUSAKA"),
  district = c("BALIZE", "BOKEDEA", "RAFUNSA"),
  subdistrict = c("AREA1", "AREA2", "AREA3")
)

# Interactively clean geonames
prep_geonames(
  target_df,
  level0 = "country", level1 = "province",
  level2 = "district",
  interactive = FALSE # replace with TRUE for interactivty
)
}

}
